{
  "version": 3,
  "sources": ["../node_modules/midifile/src/MIDIFileHeader.js", "../node_modules/midifile/src/MIDIFileTrack.js", "../node_modules/midievents/src/MIDIEvents.js", "../node_modules/utf-8/src/UTF8.js", "../node_modules/midifile/src/MIDIFile.js", "../src/load-midi.js", "../src/main.js"],
  "sourcesContent": ["'use strict';\n\n// MIDIFileHeader : Read and edit a MIDI header chunk in a given ArrayBuffer\nfunction MIDIFileHeader(buffer) {\n  let a;\n  // No buffer creating him\n  if (!buffer) {\n    a = new Uint8Array(MIDIFileHeader.HEADER_LENGTH);\n    // Adding the header id (MThd)\n    a[0] = 0x4d;\n    a[1] = 0x54;\n    a[2] = 0x68;\n    a[3] = 0x64;\n    // Adding the header chunk size\n    a[4] = 0x00;\n    a[5] = 0x00;\n    a[6] = 0x00;\n    a[7] = 0x06;\n    // Adding the file format (1 here cause it's the most commonly used)\n    a[8] = 0x00;\n    a[9] = 0x01;\n    // Adding the track count (1 cause it's a new file)\n    a[10] = 0x00;\n    a[11] = 0x01;\n    // Adding the time division (192 ticks per beat)\n    a[12] = 0x00;\n    a[13] = 0xc0;\n    // saving the buffer\n    this.datas = new DataView(a.buffer, 0, MIDIFileHeader.HEADER_LENGTH);\n    // Parsing the given buffer\n  } else {\n    if (!(buffer instanceof ArrayBuffer)) {\n      throw Error('Invalid buffer received.');\n    }\n    this.datas = new DataView(buffer, 0, MIDIFileHeader.HEADER_LENGTH);\n    // Reading MIDI header chunk\n    if (\n      !(\n        'M' === String.fromCharCode(this.datas.getUint8(0)) &&\n        'T' === String.fromCharCode(this.datas.getUint8(1)) &&\n        'h' === String.fromCharCode(this.datas.getUint8(2)) &&\n        'd' === String.fromCharCode(this.datas.getUint8(3))\n      )\n    ) {\n      throw new Error('Invalid MIDIFileHeader : MThd prefix not found');\n    }\n    // Reading chunk length\n    if (6 !== this.datas.getUint32(4)) {\n      throw new Error('Invalid MIDIFileHeader : Chunk length must be 6');\n    }\n  }\n}\n\n// Static constants\nMIDIFileHeader.HEADER_LENGTH = 14;\nMIDIFileHeader.FRAMES_PER_SECONDS = 1;\nMIDIFileHeader.TICKS_PER_BEAT = 2;\n\n// MIDI file format\nMIDIFileHeader.prototype.getFormat = function() {\n  const format = this.datas.getUint16(8);\n  if (0 !== format && 1 !== format && 2 !== format) {\n    throw new Error(\n      'Invalid MIDI file : MIDI format (' +\n        format +\n        '),' +\n        ' format can be 0, 1 or 2 only.'\n    );\n  }\n  return format;\n};\n\nMIDIFileHeader.prototype.setFormat = function(format) {\n  if (0 !== format && 1 !== format && 2 !== format) {\n    throw new Error(\n      'Invalid MIDI format given (' +\n        format +\n        '),' +\n        ' format can be 0, 1 or 2 only.'\n    );\n  }\n  this.datas.setUint16(8, format);\n};\n\n// Number of tracks\nMIDIFileHeader.prototype.getTracksCount = function() {\n  return this.datas.getUint16(10);\n};\n\nMIDIFileHeader.prototype.setTracksCount = function(n) {\n  return this.datas.setUint16(10, n);\n};\n\n// Tick compute\nMIDIFileHeader.prototype.getTickResolution = function(tempo) {\n  // Frames per seconds\n  if (this.datas.getUint16(12) & 0x8000) {\n    return 1000000 / (this.getSMPTEFrames() * this.getTicksPerFrame());\n    // Ticks per beat\n  }\n  // Default MIDI tempo is 120bpm, 500ms per beat\n  tempo = tempo || 500000;\n  return tempo / this.getTicksPerBeat();\n};\n\n// Time division type\nMIDIFileHeader.prototype.getTimeDivision = function() {\n  if (this.datas.getUint16(12) & 0x8000) {\n    return MIDIFileHeader.FRAMES_PER_SECONDS;\n  }\n  return MIDIFileHeader.TICKS_PER_BEAT;\n};\n\n// Ticks per beat\nMIDIFileHeader.prototype.getTicksPerBeat = function() {\n  var divisionWord = this.datas.getUint16(12);\n  if (divisionWord & 0x8000) {\n    throw new Error('Time division is not expressed as ticks per beat.');\n  }\n  return divisionWord;\n};\n\nMIDIFileHeader.prototype.setTicksPerBeat = function(ticksPerBeat) {\n  this.datas.setUint16(12, ticksPerBeat & 0x7fff);\n};\n\n// Frames per seconds\nMIDIFileHeader.prototype.getSMPTEFrames = function() {\n  const divisionWord = this.datas.getUint16(12);\n  let smpteFrames;\n\n  if (!(divisionWord & 0x8000)) {\n    throw new Error('Time division is not expressed as frames per seconds.');\n  }\n  smpteFrames = divisionWord & 0x7f00;\n  if (-1 === [24, 25, 29, 30].indexOf(smpteFrames)) {\n    throw new Error('Invalid SMPTE frames value (' + smpteFrames + ').');\n  }\n  return 29 === smpteFrames ? 29.97 : smpteFrames;\n};\n\nMIDIFileHeader.prototype.getTicksPerFrame = function() {\n  const divisionWord = this.datas.getUint16(12);\n\n  if (!(divisionWord & 0x8000)) {\n    throw new Error('Time division is not expressed as frames per seconds.');\n  }\n  return divisionWord & 0x00ff;\n};\n\nMIDIFileHeader.prototype.setSMTPEDivision = function(\n  smpteFrames,\n  ticksPerFrame\n) {\n  if (29.97 === smpteFrames) {\n    smpteFrames = 29;\n  }\n  if (-1 === [24, 25, 29, 30].indexOf(smpteFrames)) {\n    throw new Error('Invalid SMPTE frames value given (' + smpteFrames + ').');\n  }\n  if (0 > ticksPerFrame || 0xff < ticksPerFrame) {\n    throw new Error(\n      'Invalid ticks per frame value given (' + smpteFrames + ').'\n    );\n  }\n  this.datas.setUint8(12, 0x80 | smpteFrames);\n  this.datas.setUint8(13, ticksPerFrame);\n};\n\nmodule.exports = MIDIFileHeader;\n", "'use strict';\n\n// MIDIFileTrack : Read and edit a MIDI track chunk in a given ArrayBuffer\nfunction MIDIFileTrack(buffer, start) {\n  let a;\n  let trackLength;\n\n  // no buffer, creating him\n  if (!buffer) {\n    a = new Uint8Array(12);\n    // Adding the empty track header (MTrk)\n    a[0] = 0x4d;\n    a[1] = 0x54;\n    a[2] = 0x72;\n    a[3] = 0x6b;\n    // Adding the empty track size (4)\n    a[4] = 0x00;\n    a[5] = 0x00;\n    a[6] = 0x00;\n    a[7] = 0x04;\n    // Adding the track end event\n    a[8] = 0x00;\n    a[9] = 0xff;\n    a[10] = 0x2f;\n    a[11] = 0x00;\n    // Saving the buffer\n    this.datas = new DataView(a.buffer, 0, MIDIFileTrack.HDR_LENGTH + 4);\n    // parsing the given buffer\n  } else {\n    if (!(buffer instanceof ArrayBuffer)) {\n      throw new Error('Invalid buffer received.');\n    }\n    // Buffer length must size at least like an  empty track (8+3bytes)\n    if (12 > buffer.byteLength - start) {\n      throw new Error(\n        'Invalid MIDIFileTrack (0x' +\n          start.toString(16) +\n          ') :' +\n          ' Buffer length must size at least 12bytes'\n      );\n    }\n    // Creating a temporary view to read the track header\n    this.datas = new DataView(buffer, start, MIDIFileTrack.HDR_LENGTH);\n    // Reading MIDI track header chunk\n    if (\n      !(\n        'M' === String.fromCharCode(this.datas.getUint8(0)) &&\n        'T' === String.fromCharCode(this.datas.getUint8(1)) &&\n        'r' === String.fromCharCode(this.datas.getUint8(2)) &&\n        'k' === String.fromCharCode(this.datas.getUint8(3))\n      )\n    ) {\n      throw new Error(\n        'Invalid MIDIFileTrack (0x' +\n          start.toString(16) +\n          ') :' +\n          ' MTrk prefix not found'\n      );\n    }\n    // Reading the track length\n    trackLength = this.getTrackLength();\n    if (buffer.byteLength - start < trackLength) {\n      throw new Error(\n        'Invalid MIDIFileTrack (0x' +\n          start.toString(16) +\n          ') :' +\n          ' The track size exceed the buffer length.'\n      );\n    }\n    // Creating the final DataView\n    this.datas = new DataView(\n      buffer,\n      start,\n      MIDIFileTrack.HDR_LENGTH + trackLength\n    );\n    // Trying to find the end of track event\n    if (\n      !(\n        0xff ===\n          this.datas.getUint8(MIDIFileTrack.HDR_LENGTH + (trackLength - 3)) &&\n        0x2f ===\n          this.datas.getUint8(MIDIFileTrack.HDR_LENGTH + (trackLength - 2)) &&\n        0x00 ===\n          this.datas.getUint8(MIDIFileTrack.HDR_LENGTH + (trackLength - 1))\n      )\n    ) {\n      throw new Error(\n        'Invalid MIDIFileTrack (0x' +\n          start.toString(16) +\n          ') :' +\n          ' No track end event found at the expected index' +\n          ' (' +\n          (MIDIFileTrack.HDR_LENGTH + (trackLength - 1)).toString(16) +\n          ').'\n      );\n    }\n  }\n}\n\n// Static constants\nMIDIFileTrack.HDR_LENGTH = 8;\n\n// Track length\nMIDIFileTrack.prototype.getTrackLength = function() {\n  return this.datas.getUint32(4);\n};\n\nMIDIFileTrack.prototype.setTrackLength = function(trackLength) {\n  return this.datas.setUint32(4, trackLength);\n};\n\n// Read track contents\nMIDIFileTrack.prototype.getTrackContent = function() {\n  return new DataView(\n    this.datas.buffer,\n    this.datas.byteOffset + MIDIFileTrack.HDR_LENGTH,\n    this.datas.byteLength - MIDIFileTrack.HDR_LENGTH\n  );\n};\n\n// Set track content\nMIDIFileTrack.prototype.setTrackContent = function(dataView) {\n  let origin;\n  let destination;\n  let i;\n  let j;\n  // Calculating the track length\n  const trackLength = dataView.byteLength - dataView.byteOffset;\n\n  // Track length must size at least like an  empty track (4bytes)\n  if (4 > trackLength) {\n    throw new Error('Invalid track length, must size at least 4bytes');\n  }\n  this.datas = new DataView(\n    new Uint8Array(MIDIFileTrack.HDR_LENGTH + trackLength).buffer\n  );\n  // Adding the track header (MTrk)\n  this.datas.setUint8(0, 0x4d); // M\n  this.datas.setUint8(1, 0x54); // T\n  this.datas.setUint8(2, 0x72); // r\n  this.datas.setUint8(3, 0x6b); // k\n  // Adding the track size\n  this.datas.setUint32(4, trackLength);\n  // Copying the content\n  origin = new Uint8Array(\n    dataView.buffer,\n    dataView.byteOffset,\n    dataView.byteLength\n  );\n  destination = new Uint8Array(\n    this.datas.buffer,\n    MIDIFileTrack.HDR_LENGTH,\n    trackLength\n  );\n  for (i = 0, j = origin.length; i < j; i++) {\n    destination[i] = origin[i];\n  }\n};\n\nmodule.exports = MIDIFileTrack;\n", "'use strict';\n\n// MIDIEvents : Read and edit events from various sources (ArrayBuffer, Stream)\nfunction MIDIEvents() {\n  throw new Error('MIDIEvents function not intended to be run.');\n}\n\n// Static constants\n// Event types\nMIDIEvents.EVENT_META = 0xff;\nMIDIEvents.EVENT_SYSEX = 0xf0;\nMIDIEvents.EVENT_DIVSYSEX = 0xf7;\nMIDIEvents.EVENT_MIDI = 0x8;\n// Meta event types\nMIDIEvents.EVENT_META_SEQUENCE_NUMBER = 0x00;\nMIDIEvents.EVENT_META_TEXT = 0x01;\nMIDIEvents.EVENT_META_COPYRIGHT_NOTICE = 0x02;\nMIDIEvents.EVENT_META_TRACK_NAME = 0x03;\nMIDIEvents.EVENT_META_INSTRUMENT_NAME = 0x04;\nMIDIEvents.EVENT_META_LYRICS = 0x05;\nMIDIEvents.EVENT_META_MARKER = 0x06;\nMIDIEvents.EVENT_META_CUE_POINT = 0x07;\nMIDIEvents.EVENT_META_MIDI_CHANNEL_PREFIX = 0x20;\nMIDIEvents.EVENT_META_END_OF_TRACK = 0x2f;\nMIDIEvents.EVENT_META_SET_TEMPO = 0x51;\nMIDIEvents.EVENT_META_SMTPE_OFFSET = 0x54;\nMIDIEvents.EVENT_META_TIME_SIGNATURE = 0x58;\nMIDIEvents.EVENT_META_KEY_SIGNATURE = 0x59;\nMIDIEvents.EVENT_META_SEQUENCER_SPECIFIC = 0x7f;\n// MIDI event types\nMIDIEvents.EVENT_MIDI_NOTE_OFF = 0x8;\nMIDIEvents.EVENT_MIDI_NOTE_ON = 0x9;\nMIDIEvents.EVENT_MIDI_NOTE_AFTERTOUCH = 0xa;\nMIDIEvents.EVENT_MIDI_CONTROLLER = 0xb;\nMIDIEvents.EVENT_MIDI_PROGRAM_CHANGE = 0xc;\nMIDIEvents.EVENT_MIDI_CHANNEL_AFTERTOUCH = 0xd;\nMIDIEvents.EVENT_MIDI_PITCH_BEND = 0xe;\n// MIDI event sizes\nMIDIEvents.MIDI_1PARAM_EVENTS = [\n  MIDIEvents.EVENT_MIDI_PROGRAM_CHANGE,\n  MIDIEvents.EVENT_MIDI_CHANNEL_AFTERTOUCH,\n];\nMIDIEvents.MIDI_2PARAMS_EVENTS = [\n  MIDIEvents.EVENT_MIDI_NOTE_OFF,\n  MIDIEvents.EVENT_MIDI_NOTE_ON,\n  MIDIEvents.EVENT_MIDI_NOTE_AFTERTOUCH,\n  MIDIEvents.EVENT_MIDI_CONTROLLER,\n  MIDIEvents.EVENT_MIDI_PITCH_BEND,\n];\n\n// Create an event stream parser\nMIDIEvents.createParser = function midiEventsCreateParser(\n  stream,\n  startAt,\n  strictMode\n) {\n  // Private vars\n  // Common vars\n  var eventTypeByte;\n  var event;\n  // MIDI events vars\n  var MIDIEventType;\n  var MIDIEventChannel;\n  var MIDIEventParam1;\n\n  // Wrap DataView into a data stream\n  if (stream instanceof DataView) {\n    stream = {\n      position: startAt || 0,\n      buffer: stream,\n      readUint8: function() {\n        return this.buffer.getUint8(this.position++);\n      },\n      readUint16: function() {\n        var v = this.buffer.getUint16(this.position);\n        this.position = this.position + 2;\n        return v;\n      },\n      readUint32: function() {\n        var v = this.buffer.getUint16(this.position);\n        this.position = this.position + 2;\n        return v;\n      },\n      readVarInt: function() {\n        var v = 0;\n        var i = 0;\n        var b;\n\n        while (4 > i++) {\n          b = this.readUint8();\n\n          if (b & 0x80) {\n            v += b & 0x7f;\n            v <<= 7;\n          } else {\n            return v + b;\n          }\n        }\n        throw new Error(\n          '0x' +\n            this.position.toString(16) +\n            ':' +\n            ' Variable integer length cannot exceed 4 bytes'\n        );\n      },\n      readBytes: function(length) {\n        var bytes = [];\n\n        for (; 0 < length; length--) {\n          bytes.push(this.readUint8());\n        }\n        return bytes;\n      },\n      pos: function() {\n        return '0x' + (this.buffer.byteOffset + this.position).toString(16);\n      },\n      end: function() {\n        return this.position === this.buffer.byteLength;\n      },\n    };\n    startAt = 0;\n  }\n  // Consume stream till not at start index\n  if (0 < startAt) {\n    while (startAt--) {\n      stream.readUint8();\n    }\n  }\n  // creating the parser object\n  return {\n    // Read the next event\n    next: function() {\n      // Check available datas\n      if (stream.end()) {\n        return null;\n      }\n      // Creating the event\n      event = {\n        // Memoize the event index\n        index: stream.pos(),\n        // Read the delta time\n        delta: stream.readVarInt(),\n      };\n      // Read the eventTypeByte\n      eventTypeByte = stream.readUint8();\n      if (0xf0 === (eventTypeByte & 0xf0)) {\n        // Meta events\n        if (eventTypeByte === MIDIEvents.EVENT_META) {\n          event.type = MIDIEvents.EVENT_META;\n          event.subtype = stream.readUint8();\n          event.length = stream.readVarInt();\n          switch (event.subtype) {\n            case MIDIEvents.EVENT_META_SEQUENCE_NUMBER:\n              if (strictMode && 2 !== event.length) {\n                throw new Error(stream.pos() + ' Bad metaevent length.');\n              }\n              event.msb = stream.readUint8();\n              event.lsb = stream.readUint8();\n              return event;\n            case MIDIEvents.EVENT_META_TEXT:\n            case MIDIEvents.EVENT_META_COPYRIGHT_NOTICE:\n            case MIDIEvents.EVENT_META_TRACK_NAME:\n            case MIDIEvents.EVENT_META_INSTRUMENT_NAME:\n            case MIDIEvents.EVENT_META_LYRICS:\n            case MIDIEvents.EVENT_META_MARKER:\n            case MIDIEvents.EVENT_META_CUE_POINT:\n              event.data = stream.readBytes(event.length);\n              return event;\n            case MIDIEvents.EVENT_META_MIDI_CHANNEL_PREFIX:\n              if (strictMode && 1 !== event.length) {\n                throw new Error(stream.pos() + ' Bad metaevent length.');\n              }\n              event.prefix = stream.readUint8();\n              return event;\n            case MIDIEvents.EVENT_META_END_OF_TRACK:\n              if (strictMode && 0 !== event.length) {\n                throw new Error(stream.pos() + ' Bad metaevent length.');\n              }\n              return event;\n            case MIDIEvents.EVENT_META_SET_TEMPO:\n              if (strictMode && 3 !== event.length) {\n                throw new Error(\n                  stream.pos() + ' Tempo meta event length must be 3.'\n                );\n              }\n              event.tempo =\n                (stream.readUint8() << 16) +\n                (stream.readUint8() << 8) +\n                stream.readUint8();\n              event.tempoBPM = 60000000 / event.tempo;\n              return event;\n            case MIDIEvents.EVENT_META_SMTPE_OFFSET:\n              if (strictMode && 5 !== event.length) {\n                throw new Error(stream.pos() + ' Bad metaevent length.');\n              }\n              event.hour = stream.readUint8();\n              if (strictMode && 23 < event.hour) {\n                throw new Error(\n                  stream.pos() +\n                    ' SMTPE offset hour value must' +\n                    ' be part of 0-23.'\n                );\n              }\n              event.minutes = stream.readUint8();\n              if (strictMode && 59 < event.minutes) {\n                throw new Error(\n                  stream.pos() +\n                    ' SMTPE offset minutes value' +\n                    ' must be part of 0-59.'\n                );\n              }\n              event.seconds = stream.readUint8();\n              if (strictMode && 59 < event.seconds) {\n                throw new Error(\n                  stream.pos() +\n                    ' SMTPE offset seconds value' +\n                    ' must be part of 0-59.'\n                );\n              }\n              event.frames = stream.readUint8();\n              if (strictMode && 30 < event.frames) {\n                throw new Error(\n                  stream.pos() +\n                    ' SMTPE offset frames value must' +\n                    ' be part of 0-30.'\n                );\n              }\n              event.subframes = stream.readUint8();\n              if (strictMode && 99 < event.subframes) {\n                throw new Error(\n                  stream.pos() +\n                    ' SMTPE offset subframes value' +\n                    ' must be part of 0-99.'\n                );\n              }\n              return event;\n            case MIDIEvents.EVENT_META_KEY_SIGNATURE:\n              if (strictMode && 2 !== event.length) {\n                throw new Error(stream.pos() + ' Bad metaevent length.');\n              }\n              event.key = stream.readUint8();\n              if (strictMode && (-7 > event.key || 7 < event.key)) {\n                throw new Error(stream.pos() + ' Bad metaevent length.');\n              }\n              event.scale = stream.readUint8();\n              if (strictMode && 0 !== event.scale && 1 !== event.scale) {\n                throw new Error(\n                  stream.pos() +\n                    ' Key signature scale value must' +\n                    ' be 0 or 1.'\n                );\n              }\n              return event;\n            case MIDIEvents.EVENT_META_TIME_SIGNATURE:\n              if (strictMode && 4 !== event.length) {\n                throw new Error(stream.pos() + ' Bad metaevent length.');\n              }\n              event.data = stream.readBytes(event.length);\n              event.param1 = event.data[0];\n              event.param2 = event.data[1];\n              event.param3 = event.data[2];\n              event.param4 = event.data[3];\n              return event;\n            case MIDIEvents.EVENT_META_SEQUENCER_SPECIFIC:\n              event.data = stream.readBytes(event.length);\n              return event;\n            default:\n              if (strictMode) {\n                throw new Error(\n                  stream.pos() +\n                    ' Unknown meta event type ' +\n                    '(' +\n                    event.subtype.toString(16) +\n                    ').'\n                );\n              }\n              event.data = stream.readBytes(event.length);\n              return event;\n          }\n          // System events\n        } else if (\n          eventTypeByte === MIDIEvents.EVENT_SYSEX ||\n          eventTypeByte === MIDIEvents.EVENT_DIVSYSEX\n        ) {\n          event.type = eventTypeByte;\n          event.length = stream.readVarInt();\n          event.data = stream.readBytes(event.length);\n          return event;\n          // Unknown event, assuming it's system like event\n        } else {\n          if (strictMode) {\n            throw new Error(\n              stream.pos() +\n                ' Unknown event type ' +\n                eventTypeByte.toString(16) +\n                ', Delta: ' +\n                event.delta +\n                '.'\n            );\n          }\n          event.type = eventTypeByte;\n          event.badsubtype = stream.readVarInt();\n          event.length = stream.readUint8();\n          event.data = stream.readBytes(event.length);\n          return event;\n        }\n        // MIDI eventsdestination[index++]\n      } else {\n        // running status\n        if (0 === (eventTypeByte & 0x80)) {\n          if (!MIDIEventType) {\n            throw new Error(\n              stream.pos() + ' Running status without previous event'\n            );\n          }\n          MIDIEventParam1 = eventTypeByte;\n        } else {\n          MIDIEventType = eventTypeByte >> 4;\n          MIDIEventChannel = eventTypeByte & 0x0f;\n          MIDIEventParam1 = stream.readUint8();\n        }\n        event.type = MIDIEvents.EVENT_MIDI;\n        event.subtype = MIDIEventType;\n        event.channel = MIDIEventChannel;\n        event.param1 = MIDIEventParam1;\n        switch (MIDIEventType) {\n          case MIDIEvents.EVENT_MIDI_NOTE_OFF:\n            event.param2 = stream.readUint8();\n            return event;\n          case MIDIEvents.EVENT_MIDI_NOTE_ON:\n            event.param2 = stream.readUint8();\n\n            // If velocity is 0, it's a note off event in fact\n            if (!event.param2) {\n              event.subtype = MIDIEvents.EVENT_MIDI_NOTE_OFF;\n              event.param2 = 127; // Find a standard telling what to do here\n            }\n            return event;\n          case MIDIEvents.EVENT_MIDI_NOTE_AFTERTOUCH:\n            event.param2 = stream.readUint8();\n            return event;\n          case MIDIEvents.EVENT_MIDI_CONTROLLER:\n            event.param2 = stream.readUint8();\n            return event;\n          case MIDIEvents.EVENT_MIDI_PROGRAM_CHANGE:\n            return event;\n          case MIDIEvents.EVENT_MIDI_CHANNEL_AFTERTOUCH:\n            return event;\n          case MIDIEvents.EVENT_MIDI_PITCH_BEND:\n            event.param2 = stream.readUint8();\n            return event;\n          default:\n            if (strictMode) {\n              throw new Error(\n                stream.pos() +\n                  ' Unknown MIDI event type ' +\n                  '(' +\n                  MIDIEventType.toString(16) +\n                  ').'\n              );\n            }\n            return event;\n        }\n      }\n    },\n  };\n};\n\n// Return the buffer length needed to encode the given events\nMIDIEvents.writeToTrack = function midiEventsWriteToTrack(\n  events,\n  destination,\n  strictMode\n) {\n  var index = 0;\n  var i;\n  var j;\n  var k;\n  var l;\n\n  // Converting each event to binary MIDI datas\n  for (i = 0, j = events.length; i < j; i++) {\n    // Writing delta value\n    if (events[i].delta >>> 28) {\n      throw Error(\n        'Event #' +\n          i +\n          ': Maximum delta time value reached (' +\n          events[i].delta +\n          '/134217728 max)'\n      );\n    }\n    if (events[i].delta >>> 21) {\n      destination[index++] = ((events[i].delta >>> 21) & 0x7f) | 0x80;\n    }\n    if (events[i].delta >>> 14) {\n      destination[index++] = ((events[i].delta >>> 14) & 0x7f) | 0x80;\n    }\n    if (events[i].delta >>> 7) {\n      destination[index++] = ((events[i].delta >>> 7) & 0x7f) | 0x80;\n    }\n    destination[index++] = events[i].delta & 0x7f;\n    // MIDI Events encoding\n    if (events[i].type === MIDIEvents.EVENT_MIDI) {\n      // Adding the byte of subtype + channel\n      destination[index++] = (events[i].subtype << 4) + events[i].channel;\n      // Adding the byte of the first params\n      destination[index++] = events[i].param1;\n      // Adding a byte for the optionnal second param\n      if (-1 !== MIDIEvents.MIDI_2PARAMS_EVENTS.indexOf(events[i].subtype)) {\n        destination[index++] = events[i].param2;\n      }\n      // META / SYSEX events encoding\n    } else {\n      // Adding the event type byte\n      destination[index++] = events[i].type;\n      // Adding the META event subtype byte\n      if (events[i].type === MIDIEvents.EVENT_META) {\n        destination[index++] = events[i].subtype;\n      }\n      // Writing the event length bytes\n      if (events[i].length >>> 28) {\n        throw Error(\n          'Event #' +\n            i +\n            ': Maximum length reached (' +\n            events[i].length +\n            '/134217728 max)'\n        );\n      }\n      if (events[i].length >>> 21) {\n        destination[index++] = ((events[i].length >>> 21) & 0x7f) | 0x80;\n      }\n      if (events[i].length >>> 14) {\n        destination[index++] = ((events[i].length >>> 14) & 0x7f) | 0x80;\n      }\n      if (events[i].length >>> 7) {\n        destination[index++] = ((events[i].length >>> 7) & 0x7f) | 0x80;\n      }\n      destination[index++] = events[i].length & 0x7f;\n      if (events[i].type === MIDIEvents.EVENT_META) {\n        switch (events[i].subtype) {\n          case MIDIEvents.EVENT_META_SEQUENCE_NUMBER:\n            destination[index++] = events[i].msb;\n            destination[index++] = events[i].lsb;\n            break;\n          case MIDIEvents.EVENT_META_TEXT:\n          case MIDIEvents.EVENT_META_COPYRIGHT_NOTICE:\n          case MIDIEvents.EVENT_META_TRACK_NAME:\n          case MIDIEvents.EVENT_META_INSTRUMENT_NAME:\n          case MIDIEvents.EVENT_META_LYRICS:\n          case MIDIEvents.EVENT_META_MARKER:\n          case MIDIEvents.EVENT_META_CUE_POINT:\n            for (k = 0, l = events[i].length; k < l; k++) {\n              destination[index++] = events[i].data[k];\n            }\n            break;\n          case MIDIEvents.EVENT_META_MIDI_CHANNEL_PREFIX:\n            destination[index++] = events[i].prefix;\n            break;\n          case MIDIEvents.EVENT_META_END_OF_TRACK:\n            break;\n          case MIDIEvents.EVENT_META_SET_TEMPO:\n            destination[index++] = events[i].tempo >> 16;\n            destination[index++] = (events[i].tempo >> 8) & 0xff;\n            destination[index++] = events[i].tempo & 0xff;\n            break;\n          case MIDIEvents.EVENT_META_SMTPE_OFFSET:\n            if (strictMode && 23 < events[i].hour) {\n              throw new Error(\n                'Event #' +\n                  i +\n                  ': SMTPE offset hour value must be' +\n                  ' part of 0-23.'\n              );\n            }\n            destination[index++] = events[i].hour;\n            if (strictMode && 59 < events[i].minutes) {\n              throw new Error(\n                'Event #' +\n                  i +\n                  ': SMTPE offset minutes value must' +\n                  ' be part of 0-59.'\n              );\n            }\n            destination[index++] = events[i].minutes;\n            if (strictMode && 59 < events[i].seconds) {\n              throw new Error(\n                'Event #' +\n                  i +\n                  ': SMTPE offset seconds value must' +\n                  ' be part of 0-59.'\n              );\n            }\n            destination[index++] = events[i].seconds;\n            if (strictMode && 30 < events[i].frames) {\n              throw new Error(\n                'Event #' +\n                  i +\n                  ': SMTPE offset frames amount must' +\n                  ' be part of 0-30.'\n              );\n            }\n            destination[index++] = events[i].frames;\n            if (strictMode && 99 < events[i].subframes) {\n              throw new Error(\n                'Event #' +\n                  i +\n                  ': SMTPE offset subframes amount' +\n                  ' must be part of 0-99.'\n              );\n            }\n            destination[index++] = events[i].subframes;\n            break;\n          case MIDIEvents.EVENT_META_KEY_SIGNATURE:\n            if (\n              'number' != typeof events[i].key ||\n              -7 > events[i].key ||\n              7 < events[i].scale\n            ) {\n              throw new Error(\n                'Event #' +\n                  i +\n                  ':The key signature key must be' +\n                  ' between -7 and 7'\n              );\n            }\n            if (\n              'number' !== typeof events[i].scale ||\n              0 > events[i].scale ||\n              1 < events[i].scale\n            ) {\n              throw new Error(\n                'Event #' + i + ':' + 'The key signature scale must be 0 or 1'\n              );\n            }\n            destination[index++] = events[i].key;\n            destination[index++] = events[i].scale;\n            break;\n          // Not implemented\n          case MIDIEvents.EVENT_META_TIME_SIGNATURE:\n          case MIDIEvents.EVENT_META_SEQUENCER_SPECIFIC:\n          default:\n            for (k = 0, l = events[i].length; k < l; k++) {\n              destination[index++] = events[i].data[k];\n            }\n            break;\n        }\n        // Adding bytes corresponding to the sysex event datas\n      } else {\n        for (k = 0, l = events[i].length; k < l; k++) {\n          destination[index++] = events[i].data[k];\n        }\n      }\n    }\n  }\n};\n\n// Return the buffer length needed to encode the given events\nMIDIEvents.getRequiredBufferLength = function(events) {\n  var bufferLength = 0;\n  var i = 0;\n  var j;\n\n  // Calculating the track size by adding events lengths\n  for (i = 0, j = events.length; i < j; i++) {\n    // Computing necessary bytes to encode the delta value\n    bufferLength +=\n      events[i].delta >>> 21\n        ? 4\n        : events[i].delta >>> 14\n          ? 3\n          : events[i].delta >>> 7\n            ? 2\n            : 1;\n    // MIDI Events have various fixed lengths\n    if (events[i].type === MIDIEvents.EVENT_MIDI) {\n      // Adding a byte for subtype + channel\n      bufferLength++;\n      // Adding a byte for the first params\n      bufferLength++;\n      // Adding a byte for the optionnal second param\n      if (-1 !== MIDIEvents.MIDI_2PARAMS_EVENTS.indexOf(events[i].subtype)) {\n        bufferLength++;\n      }\n      // META / SYSEX events lengths are self defined\n    } else {\n      // Adding a byte for the event type\n      bufferLength++;\n      // Adding a byte for META events subtype\n      if (events[i].type === MIDIEvents.EVENT_META) {\n        bufferLength++;\n      }\n      // Adding necessary bytes to encode the length\n      bufferLength +=\n        events[i].length >>> 21\n          ? 4\n          : events[i].length >>> 14\n            ? 3\n            : events[i].length >>> 7\n              ? 2\n              : 1;\n      // Adding bytes corresponding to the event length\n      bufferLength += events[i].length;\n    }\n  }\n  return bufferLength;\n};\n\nmodule.exports = MIDIEvents;\n", "module.exports = {\n  isNotUTF8: isNotUTF8,\n  getCharLength: getCharLength,\n  getCharCode: getCharCode,\n  getStringFromBytes: getStringFromBytes,\n  getBytesForCharCode: getBytesForCharCode,\n  setBytesFromCharCode: setBytesFromCharCode,\n  setBytesFromString: setBytesFromString,\n};\n\n// non UTF8 encoding detection (cf README file for details)\nfunction isNotUTF8(bytes, byteOffset, byteLength) {\n  try {\n    getStringFromBytes(bytes, byteOffset, byteLength, true);\n  } catch (e) {\n    return true;\n  }\n  return false;\n}\n\nfunction getCharLength(theByte) {\n  // 4 bytes encoded char (mask 11110000)\n  if (0xf0 == (theByte & 0xf0)) {\n    return 4;\n    // 3 bytes encoded char (mask 11100000)\n  } else if (0xe0 == (theByte & 0xe0)) {\n    return 3;\n    // 2 bytes encoded char (mask 11000000)\n  } else if (0xc0 == (theByte & 0xc0)) {\n    return 2;\n    // 1 bytes encoded char\n  } else if (theByte == (theByte & 0x7f)) {\n    return 1;\n  }\n  return 0;\n}\n\n// UTF8 decoding functions\nfunction getCharCode(bytes, byteOffset, charLength) {\n  var charCode = 0,\n    mask = '';\n  byteOffset = byteOffset || 0;\n  // validate that the array has at least one byte in it\n  if (bytes.length - byteOffset <= 0) {\n    throw new Error('No more characters remaining in array.');\n  }\n  // Retrieve charLength if not given\n  charLength = charLength || getCharLength(bytes[byteOffset]);\n  if (charLength == 0) {\n    throw new Error(\n      bytes[byteOffset].toString(2) +\n        ' is not a significative' +\n        ' byte (offset:' +\n        byteOffset +\n        ').'\n    );\n  }\n  // Return byte value if charlength is 1\n  if (1 === charLength) {\n    return bytes[byteOffset];\n  }\n  // validate that the array has enough bytes to make up this character\n  if (bytes.length - byteOffset < charLength) {\n    throw new Error(\n      'Expected at least ' + charLength + ' bytes remaining in array.'\n    );\n  }\n  // Test UTF8 integrity\n  mask = '00000000'.slice(0, charLength) + 1 + '00000000'.slice(charLength + 1);\n  if (bytes[byteOffset] & parseInt(mask, 2)) {\n    throw Error(\n      'Index ' +\n        byteOffset +\n        ': A ' +\n        charLength +\n        ' bytes' +\n        ' encoded char' +\n        ' cannot encode the ' +\n        (charLength + 1) +\n        'th rank bit to 1.'\n    );\n  }\n  // Reading the first byte\n  mask = '0000'.slice(0, charLength + 1) + '11111111'.slice(charLength + 1);\n  charCode += (bytes[byteOffset] & parseInt(mask, 2)) << (--charLength * 6);\n  // Reading the next bytes\n  while (charLength) {\n    if (\n      0x80 !== (bytes[byteOffset + 1] & 0x80) ||\n      0x40 === (bytes[byteOffset + 1] & 0x40)\n    ) {\n      throw Error(\n        'Index ' +\n          (byteOffset + 1) +\n          ': Next bytes of encoded char' +\n          ' must begin with a \"10\" bit sequence.'\n      );\n    }\n    charCode += (bytes[++byteOffset] & 0x3f) << (--charLength * 6);\n  }\n  return charCode;\n}\n\nfunction getStringFromBytes(bytes, byteOffset, byteLength, strict) {\n  var charLength,\n    chars = [];\n  byteOffset = byteOffset | 0;\n  byteLength =\n    'number' === typeof byteLength\n      ? byteLength\n      : bytes.byteLength || bytes.length;\n  for (; byteOffset < byteLength; byteOffset++) {\n    charLength = getCharLength(bytes[byteOffset]);\n    if (byteOffset + charLength > byteLength) {\n      if (strict) {\n        throw Error(\n          'Index ' +\n            byteOffset +\n            ': Found a ' +\n            charLength +\n            ' bytes encoded char declaration but only ' +\n            (byteLength - byteOffset) +\n            ' bytes are available.'\n        );\n      }\n    } else {\n      chars.push(\n        String.fromCodePoint(getCharCode(bytes, byteOffset, charLength, strict))\n      );\n    }\n    byteOffset += charLength - 1;\n  }\n  return chars.join('');\n}\n\n// UTF8 encoding functions\nfunction getBytesForCharCode(charCode) {\n  if (charCode < 128) {\n    return 1;\n  } else if (charCode < 2048) {\n    return 2;\n  } else if (charCode < 65536) {\n    return 3;\n  } else if (charCode < 2097152) {\n    return 4;\n  }\n  throw new Error('CharCode ' + charCode + ' cannot be encoded with UTF8.');\n}\n\nfunction setBytesFromCharCode(charCode, bytes, byteOffset, neededBytes) {\n  charCode = charCode | 0;\n  bytes = bytes || [];\n  byteOffset = byteOffset | 0;\n  neededBytes = neededBytes || getBytesForCharCode(charCode);\n  // Setting the charCode as it to bytes if the byte length is 1\n  if (1 == neededBytes) {\n    bytes[byteOffset] = charCode;\n  } else {\n    // Computing the first byte\n    bytes[byteOffset++] =\n      (parseInt('1111'.slice(0, neededBytes), 2) << (8 - neededBytes)) +\n      (charCode >>> (--neededBytes * 6));\n    // Computing next bytes\n    for (; neededBytes > 0; ) {\n      bytes[byteOffset++] = ((charCode >>> (--neededBytes * 6)) & 0x3f) | 0x80;\n    }\n  }\n  return bytes;\n}\n\nfunction setBytesFromString(string, bytes, byteOffset, byteLength, strict) {\n  string = string || '';\n  bytes = bytes || [];\n  byteOffset = byteOffset | 0;\n  byteLength =\n    'number' === typeof byteLength ? byteLength : bytes.byteLength || Infinity;\n  for (var i = 0, j = string.length; i < j; i++) {\n    var neededBytes = getBytesForCharCode(string[i].codePointAt(0));\n    if (strict && byteOffset + neededBytes > byteLength) {\n      throw new Error(\n        'Not enought bytes to encode the char \"' +\n          string[i] +\n          '\" at the offset \"' +\n          byteOffset +\n          '\".'\n      );\n    }\n    setBytesFromCharCode(\n      string[i].codePointAt(0),\n      bytes,\n      byteOffset,\n      neededBytes,\n      strict\n    );\n    byteOffset += neededBytes;\n  }\n  return bytes;\n}\n", "'use strict';\n\n// MIDIFile : Read (and soon edit) a MIDI file in a given ArrayBuffer\n\n// Dependencies\nvar MIDIFileHeader = require('./MIDIFileHeader');\nvar MIDIFileTrack = require('./MIDIFileTrack');\nvar MIDIEvents = require('midievents');\nvar UTF8 = require('utf-8');\n\nfunction ensureArrayBuffer(buf) {\n  if (buf) {\n    if (buf instanceof ArrayBuffer) {\n      return buf;\n    }\n    if (buf instanceof Uint8Array) {\n      // Copy/convert to standard Uint8Array, because derived classes like\n      // node.js Buffers might have unexpected data in the .buffer property.\n      return new Uint8Array(buf).buffer;\n    }\n  }\n  throw new Error('Unsupported buffer type, need ArrayBuffer or Uint8Array');\n}\n\n// Constructor\nfunction MIDIFile(buffer, strictMode) {\n  var track;\n  var curIndex;\n  var i;\n  var j;\n\n  // If not buffer given, creating a new MIDI file\n  if (!buffer) {\n    // Creating the content\n    this.header = new MIDIFileHeader();\n    this.tracks = [new MIDIFileTrack()];\n    // if a buffer is provided, parsing him\n  } else {\n    buffer = ensureArrayBuffer(buffer);\n    // Minimum MIDI file size is a headerChunk size (14bytes)\n    // and an empty track (8+3bytes)\n    if (25 > buffer.byteLength) {\n      throw new Error(\n        'A buffer of a valid MIDI file must have, at least, a' +\n          ' size of 25bytes.'\n      );\n    }\n    // Reading header\n    this.header = new MIDIFileHeader(buffer, strictMode);\n    this.tracks = [];\n    curIndex = MIDIFileHeader.HEADER_LENGTH;\n    // Reading tracks\n    for (i = 0, j = this.header.getTracksCount(); i < j; i++) {\n      // Testing the buffer length\n      if (strictMode && curIndex >= buffer.byteLength - 1) {\n        throw new Error(\n          \"Couldn't find datas corresponding to the track #\" + i + '.'\n        );\n      }\n      // Creating the track object\n      track = new MIDIFileTrack(buffer, curIndex, strictMode);\n      this.tracks.push(track);\n      // Updating index to the track end\n      curIndex += track.getTrackLength() + 8;\n    }\n    // Testing integrity : curIndex should be at the end of the buffer\n    if (strictMode && curIndex !== buffer.byteLength) {\n      throw new Error('It seems that the buffer contains too much datas.');\n    }\n  }\n}\n\n// Events reading helpers\nMIDIFile.prototype.getEvents = function(type, subtype) {\n  var events;\n  var event;\n  var playTime = 0;\n  var filteredEvents = [];\n  var format = this.header.getFormat();\n  var tickResolution = this.header.getTickResolution();\n  var i;\n  var j;\n  var trackParsers;\n  var smallestDelta;\n\n  // Reading events\n  // if the read is sequential\n  if (1 !== format || 1 === this.tracks.length) {\n    for (i = 0, j = this.tracks.length; i < j; i++) {\n      // reset playtime if format is 2\n      playTime = 2 === format && playTime ? playTime : 0;\n      events = MIDIEvents.createParser(\n        this.tracks[i].getTrackContent(),\n        0,\n        false\n      );\n      // loooping through events\n      event = events.next();\n      while (event) {\n        playTime += event.delta ? event.delta * tickResolution / 1000 : 0;\n        if (event.type === MIDIEvents.EVENT_META) {\n          // tempo change events\n          if (event.subtype === MIDIEvents.EVENT_META_SET_TEMPO) {\n            tickResolution = this.header.getTickResolution(event.tempo);\n          }\n        }\n        // push the asked events\n        if (\n          (!type || event.type === type) &&\n          (!subtype || (event.subtype && event.subtype === subtype))\n        ) {\n          event.playTime = playTime;\n          filteredEvents.push(event);\n        }\n        event = events.next();\n      }\n    }\n    // the read is concurrent\n  } else {\n    trackParsers = [];\n    smallestDelta = -1;\n\n    // Creating parsers\n    for (i = 0, j = this.tracks.length; i < j; i++) {\n      trackParsers[i] = {};\n      trackParsers[i].parser = MIDIEvents.createParser(\n        this.tracks[i].getTrackContent(),\n        0,\n        false\n      );\n      trackParsers[i].curEvent = trackParsers[i].parser.next();\n    }\n    // Filling events\n    do {\n      smallestDelta = -1;\n      // finding the smallest event\n      for (i = 0, j = trackParsers.length; i < j; i++) {\n        if (trackParsers[i].curEvent) {\n          if (\n            -1 === smallestDelta ||\n            trackParsers[i].curEvent.delta <\n              trackParsers[smallestDelta].curEvent.delta\n          ) {\n            smallestDelta = i;\n          }\n        }\n      }\n      if (-1 !== smallestDelta) {\n        // removing the delta of previous events\n        for (i = 0, j = trackParsers.length; i < j; i++) {\n          if (i !== smallestDelta && trackParsers[i].curEvent) {\n            trackParsers[i].curEvent.delta -=\n              trackParsers[smallestDelta].curEvent.delta;\n          }\n        }\n        // filling values\n        event = trackParsers[smallestDelta].curEvent;\n        playTime += event.delta ? event.delta * tickResolution / 1000 : 0;\n        if (event.type === MIDIEvents.EVENT_META) {\n          // tempo change events\n          if (event.subtype === MIDIEvents.EVENT_META_SET_TEMPO) {\n            tickResolution = this.header.getTickResolution(event.tempo);\n          }\n        }\n        // push midi events\n        if (\n          (!type || event.type === type) &&\n          (!subtype || (event.subtype && event.subtype === subtype))\n        ) {\n          event.playTime = playTime;\n          event.track = smallestDelta;\n          filteredEvents.push(event);\n        }\n        // getting next event\n        trackParsers[smallestDelta].curEvent = trackParsers[\n          smallestDelta\n        ].parser.next();\n      }\n    } while (-1 !== smallestDelta);\n  }\n  return filteredEvents;\n};\n\nMIDIFile.prototype.getMidiEvents = function() {\n  return this.getEvents(MIDIEvents.EVENT_MIDI);\n};\n\nMIDIFile.prototype.getLyrics = function() {\n  var events = this.getEvents(MIDIEvents.EVENT_META);\n  var texts = [];\n  var lyrics = [];\n  var event;\n  var i;\n  var j;\n\n  for (i = 0, j = events.length; i < j; i++) {\n    event = events[i];\n    // Lyrics\n    if (event.subtype === MIDIEvents.EVENT_META_LYRICS) {\n      lyrics.push(event);\n      // Texts\n    } else if (event.subtype === MIDIEvents.EVENT_META_TEXT) {\n      // Ignore special texts\n      if ('@' === String.fromCharCode(event.data[0])) {\n        if ('T' === String.fromCharCode(event.data[1])) {\n          // console.log('Title : ' + event.text.substring(2));\n        } else if ('I' === String.fromCharCode(event.data[1])) {\n          // console.log('Info : ' + event.text.substring(2));\n        } else if ('L' === String.fromCharCode(event.data[1])) {\n          // console.log('Lang : ' + event.text.substring(2));\n        }\n        // karaoke text follows, remove all previous text\n      } else if (\n        0 === String.fromCharCode.apply(String, event.data).indexOf('words')\n      ) {\n        texts.length = 0;\n        // console.log('Word marker found');\n        // Karaoke texts\n        // If playtime is greater than 0\n      } else if (0 !== event.playTime) {\n        texts.push(event);\n      }\n    }\n  }\n  // Choosing the right lyrics\n  if (2 < lyrics.length) {\n    texts = lyrics;\n  } else if (!texts.length) {\n    texts = [];\n  }\n  // Convert texts and detect encoding\n  try {\n    texts.forEach(function(event) {\n      event.text = UTF8.getStringFromBytes(event.data, 0, event.length, true);\n    });\n  } catch (e) {\n    texts.forEach(function(event) {\n      event.text = event.data\n        .map(function(c) {\n          return String.fromCharCode(c);\n        })\n        .join('');\n    });\n  }\n  return texts;\n};\n\n// Basic events reading\nMIDIFile.prototype.getTrackEvents = function(index) {\n  var event;\n  var events = [];\n  var parser;\n  if (index > this.tracks.length || 0 > index) {\n    throw Error('Invalid track index (' + index + ')');\n  }\n  parser = MIDIEvents.createParser(\n    this.tracks[index].getTrackContent(),\n    0,\n    false\n  );\n  event = parser.next();\n  do {\n    events.push(event);\n    event = parser.next();\n  } while (event);\n  return events;\n};\n\n// Basic events writting\nMIDIFile.prototype.setTrackEvents = function(index, events) {\n  var bufferLength;\n  var destination;\n\n  if (index > this.tracks.length || 0 > index) {\n    throw Error('Invalid track index (' + index + ')');\n  }\n  if (!events || !events.length) {\n    throw Error('A track must contain at least one event, none given.');\n  }\n  bufferLength = MIDIEvents.getRequiredBufferLength(events);\n  destination = new Uint8Array(bufferLength);\n  MIDIEvents.writeToTrack(events, destination);\n  this.tracks[index].setTrackContent(destination);\n};\n\n// Remove a track\nMIDIFile.prototype.deleteTrack = function(index) {\n  if (index > this.tracks.length || 0 > index) {\n    throw Error('Invalid track index (' + index + ')');\n  }\n  this.tracks.splice(index, 1);\n  this.header.setTracksCount(this.tracks.length);\n};\n\n// Add a track\nMIDIFile.prototype.addTrack = function(index) {\n  var track;\n\n  if (index > this.tracks.length || 0 > index) {\n    throw Error('Invalid track index (' + index + ')');\n  }\n  track = new MIDIFileTrack();\n  if (index === this.tracks.length) {\n    this.tracks.push(track);\n  } else {\n    this.tracks.splice(index, 0, track);\n  }\n  this.header.setTracksCount(this.tracks.length);\n};\n\n// Retrieve the content in a buffer\nMIDIFile.prototype.getContent = function() {\n  var bufferLength;\n  var destination;\n  var origin;\n  var i;\n  var j;\n  var k;\n  var l;\n  var m;\n  var n;\n\n  // Calculating the buffer content\n  // - initialize with the header length\n  bufferLength = MIDIFileHeader.HEADER_LENGTH;\n  // - add tracks length\n  for (i = 0, j = this.tracks.length; i < j; i++) {\n    bufferLength += this.tracks[i].getTrackLength() + 8;\n  }\n  // Creating the destination buffer\n  destination = new Uint8Array(bufferLength);\n  // Adding header\n  origin = new Uint8Array(\n    this.header.datas.buffer,\n    this.header.datas.byteOffset,\n    MIDIFileHeader.HEADER_LENGTH\n  );\n  for (i = 0, j = MIDIFileHeader.HEADER_LENGTH; i < j; i++) {\n    destination[i] = origin[i];\n  }\n  // Adding tracks\n  for (k = 0, l = this.tracks.length; k < l; k++) {\n    origin = new Uint8Array(\n      this.tracks[k].datas.buffer,\n      this.tracks[k].datas.byteOffset,\n      this.tracks[k].datas.byteLength\n    );\n    for (m = 0, n = this.tracks[k].datas.byteLength; m < n; m++) {\n      destination[i++] = origin[m];\n    }\n  }\n  return destination.buffer;\n};\n\n// Exports Track/Header constructors\nMIDIFile.Header = MIDIFileHeader;\nMIDIFile.Track = MIDIFileTrack;\n\nmodule.exports = MIDIFile;\n", "import MIDIFile from \"midifile\";\r\nimport MIDIEvents from \"midievents\";\r\n\r\nfunction getRanges(notes) {\r\n  const ranges = [];\r\n\r\n  const pressedNotes = new Map();\r\n\r\n  for (const note of notes) {\r\n    if (note.subtype === MIDIEvents.EVENT_MIDI_NOTE_ON) {\r\n      pressedNotes.set(note.param1, note);\r\n    } else if (note.subtype === MIDIEvents.EVENT_MIDI_NOTE_OFF) {\r\n      const startNote = pressedNotes.get(note.param1);\r\n\r\n      const duration = note.playTime - startNote.playTime;\r\n\r\n      // artificially shorten duration so that\r\n      // clustered notes don't \"merge\" together\r\n      note.playTime = startNote.playTime + duration * 0.8;\r\n\r\n      ranges.push({\r\n        startNote: startNote,\r\n        endNote: note,\r\n      });\r\n    }\r\n  }\r\n\r\n  return ranges;\r\n}\r\n\r\nfunction getAllVoices(ranges) {\r\n  const voices = [];\r\n\r\n  function isBetween(x, a, b) {\r\n    return x >= a && x <= b;\r\n  }\r\n\r\n  function rangeOverlap(r1, r2) {\r\n    const start1 = r1.startNote.playTime;\r\n    const end1 = r1.endNote.playTime;\r\n    const start2 = r2.startNote.playTime;\r\n    const end2 = r2.endNote.playTime;\r\n\r\n    return (\r\n      isBetween(start1, start2, end2) ||\r\n      isBetween(end1, start2, end2) ||\r\n      isBetween(start2, start1, end1) ||\r\n      isBetween(end2, start1, end1)\r\n    );\r\n  }\r\n\r\n  function insertRange(r) {\r\n    for (const v of voices) {\r\n      const existingNote = v.at(-1);\r\n      if (!rangeOverlap(r, existingNote)) {\r\n        v.push(r);\r\n        return;\r\n      }\r\n    }\r\n\r\n    voices.push([r]);\r\n  }\r\n\r\n  for (const r of ranges) {\r\n    insertRange(r);\r\n  }\r\n\r\n  return voices;\r\n}\r\n\r\nfunction voices2desmos(voices) {\r\n  return `V\\\\left(x\\\\right)=\\\\left[${voices.map((v) => {\r\n    return `\\\\left\\\\{${v.map((range) => {\r\n      return `${Math.round(range.startNote.playTime)}<x<${Math.round(\r\n        range.endNote.playTime\r\n      )}:${range.startNote.param1}`;\r\n    })},0\\\\right\\\\}`;\r\n  })}\\\\right]`;\r\n}\r\n\r\nfunction list(...inner) {\r\n  return `\\\\left[${inner}\\\\right]`;\r\n}\r\n\r\nfunction voices2desmosFast(voices) {\r\n  const time2index = (t) => Math.floor(t / 50);\r\n  const timeTruncate = (t) =>\r\n    Math.floor(((t - 50 * time2index(t)) / 50) * 254) + 1;\r\n\r\n  return `V\\\\left(x\\\\right)=${list(\r\n    ...voices.map((v) => {\r\n      const regions = new Array(10000).fill(0).map((v) => []);\r\n      let x = 0;\r\n      for (const range of v) {\r\n        const startRegion = time2index(range.startNote.playTime);\r\n        const endRegion = time2index(range.endNote.playTime);\r\n        regions[startRegion].push({\r\n          note: range.startNote.param1,\r\n          time: timeTruncate(range.startNote.playTime),\r\n        });\r\n        for (let i = startRegion + 1; i <= endRegion; i++) {\r\n          regions[i].push({\r\n            note: range.startNote.param1,\r\n            time: 1,\r\n          });\r\n        }\r\n        regions[endRegion].push({\r\n          note: 0,\r\n          time: timeTruncate(range.endNote.playTime),\r\n        });\r\n      }\r\n\r\n      for (const r of regions) {\r\n        if (r.length > 3) {\r\n          console.log(\r\n            \"UH OH! MORE THAN THREE NOTE CHANGES IN A SINGLE REGION!\"\r\n          );\r\n        }\r\n      }\r\n\r\n      let encodedRegions = regions.map((r) => {\r\n        let encoded = 0;\r\n        let bitshift = 0;\r\n        for (const noteChange of r.slice(0, 3)) {\r\n          encoded += noteChange.time * 2 ** bitshift;\r\n          encoded += noteChange.note * 2 ** (bitshift + 8);\r\n          bitshift += 16;\r\n        }\r\n\r\n        return encoded;\r\n      });\r\n\r\n      return `${list(encodedRegions)}\\\\left[x\\\\right]`;\r\n    })\r\n  )}`;\r\n}\r\n\r\nexport async function convertMidiToDesmos(midi) {\r\n  const midifile = new MIDIFile(midi);\r\n\r\n  const events = midifile.getEvents();\r\n\r\n  const ranges = getRanges(events);\r\n\r\n  const voices = getAllVoices(ranges);\r\n\r\n  return voices2desmosFast(voices);\r\n}\r\n", "import { convertMidiToDesmos } from \"./load-midi.js\";\r\n\r\nconst input = document.getElementById(\"input\");\r\nconst output = document.getElementById(\"output\");\r\n\r\ninput.addEventListener(\"change\", async (e) => {\r\n  const file = input.files[0];\r\n  const str = await convertMidiToDesmos(await file.arrayBuffer());\r\n  output.value = str;\r\n});\r\n"],
  "mappings": "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",
  "names": ["MIDIEvents", "MIDIEvents", "MIDIFile", "event", "MIDIEvents", "v", "MIDIFile"]
}
